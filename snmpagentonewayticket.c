#include "snmpagentonewayticket.h"

#include "get_rss.h"

static struct SNMP_SVC_ONEWAYTICKET counter;

void inline set_requestcount(uint32_t value)
{
	counter.requestcount = value;
}

void inline set_errorcount(uint32_t value)
{
	counter.errorcount = value;
}

void inline set_ticketssold(uint32_t value)
{
	counter.ticketssold = value;
}

void inc_requestcount()
{
	counter.requestcount++;
}

void inc_errorcount()
{
	counter.errorcount++;
}

void inc_ticketssold()
{
	counter.ticketssold++;
}


#ifdef __cplusplus
extern "C" {
#endif

void init_mibs() {
	init_databaseinstance();
	init_starttime();
	init_requestcount();
	init_memorypeak();
	init_memorycurrent();
	init_errorcount();
	init_ticketssold();
}

/** Initializes the databaseinstance module */
void
init_databaseinstance(void)
{
    const oid databaseinstance_oid[] = { 1,3,6,1,4,1,46821,1,1,1,1 };

  DEBUGMSGTL(("databaseinstance", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("databaseinstance", handle_databaseinstance,
                               databaseinstance_oid, OID_LENGTH(databaseinstance_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_databaseinstance(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
            		&counter.databaseinstance,
                    0);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_databaseinstance\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

/** Initializes the starttime module */
void
init_starttime(void)
{
    const oid starttime_oid[] = { 1,3,6,1,4,1,46821,1,1,1,2 };
    DEBUGMSGTL(("starttime", "Initializing\n"));

    counter.starttime = time(NULL);

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("starttime", handle_starttime,
                               starttime_oid, OID_LENGTH(starttime_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_starttime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.starttime,
					sizeof(counter.starttime));
            break;
        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_starttime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the requestcount module */
void
init_requestcount(void)
{
    const oid requestcount_oid[] = { 1,3,6,1,4,1,46821,1,1,2,1 };

  DEBUGMSGTL(("requestcount", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("requestcount", handle_requestcount,
                               requestcount_oid, OID_LENGTH(requestcount_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_requestcount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.requestcount,
            		sizeof(counter.requestcount));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_requestcount\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the memorypeak module */
void
init_memorypeak(void)
{
    const oid memorypeak_oid[] = { 1,3,6,1,4,1,46821,1,1,2,2 };

  DEBUGMSGTL(("memorypeak", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memorypeak", handle_memorypeak,
                               memorypeak_oid, OID_LENGTH(memorypeak_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_memorypeak(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
        	counter.memorypeak = getPeakRSS() / 1024;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.memorypeak,
            		sizeof(counter.memorypeak));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memorypeak\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the memorycurrent module */
void
init_memorycurrent(void)
{
    const oid memorycurrent_oid[] = { 1,3,6,1,4,1,46821,1,1,2,3 };

  DEBUGMSGTL(("memorycurrent", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memorycurrent", handle_memorycurrent,
                               memorycurrent_oid, OID_LENGTH(memorycurrent_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_memorycurrent(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
        	counter.memorycurrent = getCurrentRSS() / 1024;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.memorycurrent,
            		sizeof(counter.memorycurrent));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memorycurrent\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the errorcount module */
void
init_errorcount(void)
{
    const oid errorcount_oid[] = { 1,3,6,1,4,1,46821,1,1,2,4 };

  DEBUGMSGTL(("errorcount", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("errorcount", handle_errorcount,
                               errorcount_oid, OID_LENGTH(errorcount_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_errorcount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.errorcount,
            		sizeof(counter.errorcount));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_errorcount\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the ticketssold module */
void
init_ticketssold(void)
{
    const oid ticketssold_oid[] = { 1,3,6,1,4,1,46821,1,1,2,5 };

  DEBUGMSGTL(("ticketssold", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ticketssold", handle_ticketssold,
                               ticketssold_oid, OID_LENGTH(ticketssold_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_ticketssold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            		&counter.ticketssold,
            		sizeof(counter.ticketssold));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ticketssold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#ifdef __cplusplus
}
#endif

